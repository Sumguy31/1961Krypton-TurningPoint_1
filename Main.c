#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  catlim,         sensorTouch)
#pragma config(Sensor, dgtl2,  encR,           sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  encL,           sensorQuadEncoder)
#pragma config(Motor,  port1,           Left1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Left2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Left3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           catapult,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Right4,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Left4,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Right1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Right3,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "Third.h"

/////////////////////////////////////////////////////////////////////////////
//
//												global variables
//
/////////////////////////////////////////////////////////////////////////////

bool checkIntake = true;
//bool extend_front = false;
bool bMB_park = false;
bool direction;
bool catapult_engage = true;

int count = 0;

const short leftButton = 1;		// variable for LCD left button
const short centerButton = 2;	// variable for LCD center button
const short rightButton = 4;	// variable for LCD center button

bool bSelected = false;

int batteryLevel;

void getBatteryLevel(){
	batteryLevel = nImmediateBatteryLevel;

	datalogDataGroupStart();
	datalogAddValue(1, batteryLevel);
	datalogDataGroupEnd();

}
//////////////////////////////////////////////////////////////////////////////
//
//														Autonomous Functions
//
//
/////////////////////////////////////////////////////////////////////////////
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void setRightDrive(int power){
	motor[Right1] = power;
	motor[Right2] = power;
	motor[Right3] = power;
	motor[Right4] = power;
}
void setLeftDrive(int power){
	motor[Left1] = power;
	motor[Left2] = power;
	motor[Left3] = power;
	motor[Left4] = power;
}

void RotateLeft(float target, int power, bool brake){
	//int ticks = (target/(3.14*4))*360;
	SensorValue[encR]=0;
	SensorValue[encL]=0;
	while(abs(SensorValue[encL]) < target){
		setLeftDrive(power);
		setRightDrive(-power);
	}

	if(brake){
		setLeftDrive(-30);
		setRightDrive(30);
		wait1Msec(200);
		setLeftDrive(0);
		setRightDrive(0);
	}
	else{
		setLeftDrive(0);
		setRightDrive(0);
	}
}

void RotateRight(float target, int power, bool brake){
	//int ticks = (target/(3.14*4))*360;
	SensorValue[encR]=0;
	SensorValue[encL]=0;
	while(abs(SensorValue[encL]) < target){
		setLeftDrive(-power);
		setRightDrive(power);
	}
	if(brake){
		setLeftDrive(30);
		setRightDrive(-30);
		wait1Msec(200);
		setLeftDrive(0);
		setRightDrive(0);
	}
	else{
		setLeftDrive(0);
		setRightDrive(0);
	}
}

void moveForward(float target, int power, bool brake){
	int ticks = (target/(3.14*4))*360;
	SensorValue[encR]=0;
	SensorValue[encL]=0;
	while(abs(SensorValue[encL]) < ticks){
		setLeftDrive(power);
		setRightDrive(power);
	}
	if(brake){
		setLeftDrive(-15);
		setRightDrive(-15);
		wait1Msec(100);
		setLeftDrive(0);
		setRightDrive(0);
	}
	else{
		setLeftDrive(0);
		setRightDrive(0);
	}
}

void moveBackward(float target, int power, bool brake){
	int ticks = (target/(3.14*4))*360;
	time1[T3] = 0;
	SensorValue[encR]=0;
	SensorValue[encL]=0;
	while(abs(SensorValue[encL]) <ticks && time1[T3] < 2000){
		setLeftDrive(-power);
		setRightDrive(-power);
	}
	if(brake){
		setLeftDrive(15);
		setRightDrive(15);
		wait1Msec(200);
		setLeftDrive(0);
		setRightDrive(0);
	}
	else{
		setLeftDrive(0);
		setRightDrive(0);
	}
}

void armCatapult(){
	while(!SensorValue[catlim]){
		motor[catapult] = 127;
	}
	motor[catapult] = 20;
}
void fireCatapult(){
	motor[catapult] = 127;
	wait1Msec(250);
	motor[catapult] = 20;
}

task auto_intake_cont{
	while(checkIntake){
		motor[intake] = SensorValue[catlim] ? 127: 0;
	}
}
/*void moveBackPick(int target, int power){
SensorValue[encR]=0;
SensorValue[encL]=0;
int ticks = (target/(3.14*4))*360;
time1[T3] = 0;
while(abs(SensorValue[encL]) < ticks && time1[T3] < 2000){
setLeftDrive(-power);
setRightDrive(-power);
if(SensorValue[catlim] == 1){
motor[intake] = 127;
}
else{
motor[intake] = 0;
}
}
motor[intake] = 0;
setLeftDrive(15);
setRightDrive(15);
wait1Msec(200);
setLeftDrive(0);
setRightDrive(0);
}*/
////////////////////////////////////////////////////////////////////////////
//
//																PID
//
////////////////////////////////////////////////////////////////////////////

float spdRVal;

void setkpFactor(){
	if (nImmediateBatteryLevel >= 8400) {
		spdRVal = speedRFactor[0];
	}
	else if (nImmediateBatteryLevel > 8100) {
		spdRVal = speedRFactor[1];
	}
	else if (nImmediateBatteryLevel > 7800) {
		spdRVal = speedRFactor[2];
	}
	else {
		spdRVal = speedRFactor[3];

	}

}
/////////////////////////////////////////////////////////////////////////////

typedef struct{
	float current;
	float kP;
	float kI;
	float kD;
	float target;
	float integral;
	float error;
	float derivative;
	float lastError;
} PID;

PID sRotatePid;

int iRotatePID(int target){
	sRotatePid.kP = 0.08; //0.08 value works at ~90deg
	sRotatePid.kI = 0;
	sRotatePid.kD = 0.2;

	sRotatePid.current = SensorValue[gyro];
	sRotatePid.error = target - sRotatePid.current;
	sRotatePid.integral += sRotatePid.error;
	sRotatePid.derivative = sRotatePid.error - sRotatePid.lastError;
	sRotatePid.lastError = sRotatePid.error;

	return ( ((sRotatePid.error)*(sRotatePid.kP)) + ((sRotatePid.derivative)*(sRotatePid.kD)) + ((sRotatePid.integral)*(sRotatePid.kI)) );
}

PID sMovePid;

int iMovePid(int target){
	sMovePid.kP = 0.08;
	sMovePid.kI = 0;
	sMovePid.kD = 0.22;

	sMovePid.current = (SensorValue[encL]);
	sMovePid.error = target - sMovePid.current;
	sMovePid.integral += sMovePid.error;
	sMovePid.derivative = sMovePid.error - sMovePid.lastError;
	sMovePid.lastError = sRotatePid.error;

	return ( ((sMovePid.error)*(sMovePid.kP)) + ((sMovePid.derivative)*(sMovePid.kD)) + ((sMovePid.integral)*(sMovePid.kI)) );
}

void RotatePid(int targetDegree){
	int	rElement = (abs(targetDegree) * 2 / 10) - 1;
	int target = rotateArray[rElement][0];
	float limitFactor = rotateArray[rElement][1];


	SensorValue[gyro] = 0;
	time1[T2] = 0;
	if (targetDegree > 0) {
		while((abs(target-SensorValue[gyro])> (limitFactor)) && (time1[T2] < 1500) ){
			int Output_PID = iRotatePID(target);
			int power = abs(Output_PID) > 60 ? 60 *(Output_PID/abs(Output_PID)) : Output_PID;

			setLeftDrive(power*spdRVal);
			setRightDrive(-power*spdRVal);
		}
	}
	else
	{
		while((abs(-target-SensorValue[gyro])> (limitFactor)) && (time1[T2] < 1500) ){
			int Output_PID = iRotatePID(-target);
			int power = abs(Output_PID) > 60 ? 60 *(Output_PID/abs(Output_PID)) : Output_PID;

			setLeftDrive(power*spdRVal);
			setRightDrive(-power*spdRVal);
		}
	}

	setLeftDrive(0);
	setRightDrive(0);

	SensorValue[gyro] = 0;
}



void MoveFPid(int target){
	int mElement = (abs(target)/3) - 1;
	int ticks = moveFArray[mElement][0];
	int lastDist = moveFArray[mElement][1];

	SensorValue[encL] = 0;

	while(abs(ticks-SensorValue[encL])> lastDist){
		int power = abs(iMovePid(ticks)) > 60 ? 60*(iMovePid(ticks)/abs(iMovePid(ticks))) : iMovePid(ticks);
		setLeftDrive(power);
		setRightDrive(power);
	}

	setLeftDrive(0);
	setRightDrive(0);
}

void MoveBPid(int target){
	int mElement = (abs(target)/3) - 1;
	int ticks = moveBArray[mElement][0];
	int lastDist = moveBArray[mElement][1];

	SensorValue[encL] = 0;

	while(abs(-ticks - SensorValue[encL])> lastDist){
		int power = abs(iMovePid(ticks)) > 60 ? 60*(iMovePid(ticks)/abs(iMovePid(ticks))) : iMovePid(ticks);
		setLeftDrive(-power);
		setRightDrive(-power);
	}

	setLeftDrive(0);
	setRightDrive(0);
}


/////////////////////////////////////////////////////////////////////////////
//															Master Auton
/////////////////////////////////////////////////////////////////////////////

void moveBackPark(){
	//true >> turn right
	//false >> turn left
	MoveBPid(3);
	/*	if(direction){
	RotatePid(-5);
	MoveBPid(6);
	RotatePid(5);
	}
	else{
	RotatePid(5);
	MoveBPid(6);
	RotatePid(-5);
	}*/
	moveBackward(11,60,false);
	MoveBPid(69);
	if(direction){
		RotatePid(-90);
	}
	else{
		RotatePid(90);
	}
	moveBackward(37,127,true);
}



void blueFront(){

	armCatapult();
	//motor[intake] = 127;
	moveBackward(38,60,true);
	//moveBackPick(38,60);
	wait1Msec(500);
	moveForward(25,60,false);
	moveForward(18,20,false);
	wait1Msec(300);
	moveBackward(4,60,true);
	RotateLeft(302, 60,true);


	moveForward(13, 60, true);//16.5 default
	wait1Msec(1000);
	fireCatapult();
	wait1Msec(250);
	RotateRight(57,60,true);
	moveForward(20,70,false);
	/*
	armCatapult();
	wait1Msec(750);
	MoveBPid(47);
	SensorValue[encL]=0;
	wait1Msec(550);
	SensorValue[encL]=0;
	moveForward(1,60,false);
	MoveFPid(40);
	wait1Msec(250);
	RotatePid(90);
	MoveFPid(15);
	wait1Msec(1000);
	fireCatapult();
	RotatePid(-5);
	moveForward(20,60,false);
	moveForward(15,80,false);

	if(extend_front){
	wait1Msec(100);
	moveBackward(7.5,60,true);
	RotatePid(-45);

	checkIntake = false;
	stopTask(auto_intake_cont);
	motor[intake] = -127;


	//MoveBPid(85);
	moveBackward(68,40,true);
	MoveFPid(20);
	//moveForward(15,60,true);

	RotatePid(45);
	moveBackward(50,127,true);
	}*/

	if(bMB_park){
		direction = true;
		moveBackPark();
	}
}

void redFront(){
	armCatapult();
	//motor[intake] = 127;
	moveBackward(38,60,true);
	//moveBackPick(38,60);
	wait1Msec(500);
	moveForward(25,60,false);
	moveForward(18,20,false);
	wait1Msec(300);
	moveBackward(4,60,true);
	RotateRight(295, 60,true);
	//PIDGyroControl(975,-1,500,200);
	moveForward(13, 60, true);//16.5 default
	wait1Msec(1000);
	fireCatapult();
	wait1Msec(250);
	RotateLeft(55,60,true);
	moveForward(20,70,false);
	/*armCatapult();
	wait1Msec(750);
	MoveBPid(47);
	wait1Msec(550);
	moveForward(2,60,false);
	MoveFPid(36);
	wait1Msec(250);
	RotateRight(60,60,false);
	RotatePid(-85);
	moveForward(2.5,40,false);
	MoveFPid(12);
	wait1Msec(1000);
	fireCatapult();
	moveForward(20,60,true);
	RotateLeft(5,60,false);
	moveForward(30,80,false);

	if(extend_front){
	wait1Msec(100);
	moveBackward(7.5,60,true);
	RotatePid(45);

	checkIntake = false;
	stopTask(auto_intake_cont);
	motor[intake] = -127;


	//MoveBPid(85);
	moveBackward(70,40,true);
	MoveFPid(20);
	//moveForward(15,60,true);

	RotatePid(-45);
	moveBackward(50,127,true);
	}*/
	if(bMB_park){
		SensorValue[encL] =0;
		//MoveBPid(3);

		moveBackward(15,60,false);
		MoveBPid(72);

		RotatePid(90);

		moveBackward(37,127,true);
	}
}

void blueBack(){
	armCatapult();
	motor[intake] = 127;
	moveBackward(37,60,true);
	wait1Msec(500);
	motor[intake] = 0;
	//PIDGyroControl(975,-1,500,200);
	RotateRight(296, 60,true);
	moveBackward(27,127,true);
}

void redBack(){
	armCatapult();
	motor[intake] = 127;
	moveBackward(37,60,true);
	wait1Msec(500);
	motor[intake] = 0;
	//PIDGyroControl(975,1,500,200);
	RotateLeft(296, 60,true);
	moveBackward(27,127,true);
}

void progSkills(){

	//high climb

}
/////////////////////////////////////////////////////////////////////////////
//
//
//														Driver Controls
//
//
/////////////////////////////////////////////////////////////////////////////

void arcadeControl(){
	int Rightpower;
	int Leftpower;
	int deadZone = 20;
	if(abs(vexRT[Ch2]) > deadZone || abs(vexRT[Ch1]) > deadZone){
		Rightpower = vexRT[Ch2]+vexRT[Ch1];
		Leftpower = vexRT[Ch2]-vexRT[Ch1];
	}
	else{
		Rightpower = 0;
		Leftpower = 0;
	}
	setLeftDrive(Leftpower);
	setRightDrive(Rightpower);
}

void intakeControl(){
	if(vexRT[Btn5U] && !vexRT[Btn5D] && SensorValue[catlim]){
		motor[intake] = 127;
	}
	else if(!vexRT[Btn5U] && vexRT[Btn5D]){
		motor[intake] = -127;
	}
	else{
		motor[intake] = 0;
	}
}

/*void catapultControl(){
if(!vexRT[Btn6U]){
if(!SensorValue[catlim]){
motor[catapult] = 127;
}
else{
motor[catapult] = 20;
}
}
else if(vexRT[Btn6U]){
motor[catapult] = 127;
}
else{
}
}*/
task t_engage_catapult{
	while(true){

		while(catapult_engage){
			if(vexRT[Btn8D]){
				catapult_engage = false;
			}
			wait1Msec(1);
		}
		while(!catapult_engage){
			if(vexRT[Btn8D]){
				catapult_engage = true;
			}
			wait1Msec(1);
		}

	}
}

task t_catapultControl{
	while(true){
		while(catapult_engage){
			if(!vexRT[Btn6U]){
				if(!SensorValue[catlim]){
					motor[catapult] = 127;
				}
				else{
					motor[catapult] = 20;
				}
			}
			else if(vexRT[Btn6U]){
				motor[catapult] = 127;
			}
			else{
			}
		}
		while(!catapult_engage){
			motor[catapult] = 0;
		}
	}
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	//bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	SensorFullCount[gyro] = 43200;
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	while(nLCDButtons != centerButton && bIfiRobotDisabled && !bSelected){
		switch(count){
		case 0:
			displayLCDCenteredString(0, "0. Do Nothing");
			displayLCDCenteredString(1, "<     Enter    >");
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 5;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 1:
			//Display second choice
			displayLCDCenteredString(0, "1. Blue Front");
			displayLCDCenteredString(1, "<     Enter    >");
			//waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display second choice
			displayLCDCenteredString(0, "2. Red Front");
			displayLCDCenteredString(1, "<     Enter    >");
			//waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 3:
			//Display second choice
			displayLCDCenteredString(0, "3. Blue Back");
			displayLCDCenteredString(1, "<     Enter    >");
			//waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 4:
			//Display second choice
			displayLCDCenteredString(0, "4. Red Back");
			displayLCDCenteredString(1, "<     Enter    >");
			//waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 5:
			//Display second choice
			displayLCDCenteredString(0, "5. Skills Auto");
			displayLCDCenteredString(1, "<     Enter    >");
			//waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		}
	}

	while(bIfiRobotDisabled){
		switch(count){

		case 0:
			displayLCDCenteredString(0, "Nothing");
			displayLCDCenteredString(1, "Selected!");
			break;

		case 1:
			displayLCDCenteredString(0, "1. Blue Front");
			displayLCDCenteredString(1, "Selected!");
			break;

		case 2:
			displayLCDCenteredString(0, "2. Red Front");
			displayLCDCenteredString(1, "Selected!");
			break;

		case 3:
			displayLCDCenteredString(0, "3. Blue Back");
			displayLCDCenteredString(1, "Selected!");
			break;

		case 4:
			displayLCDCenteredString(0, "4. Red Back");
			displayLCDCenteredString(1, "Selected!");
			break;

		case 5:
			displayLCDCenteredString(0, "5. Skills Auto");
			displayLCDCenteredString(1, "Selected!");
			break;
		}
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	displayLCDNumber(0, 6, count);
	displayLCDCenteredString(1, "is Running!");
	setkpFactor();
	getBatteryLevel();
	SensorValue[gyro] = 0;

	startTask(auto_intake_cont);

	if(count == 1){
		blueFront();
	}

	else if(count == 2){
		redFront();
	}

	else if (count == 3){
		blueBack();
	}

	else if (count == 4){
		redBack();
	}
	else if (count == 5){
		//PIDGyroControl(450,1,1000,200);
		//progSkills(false);
		direction = false;
		moveBackPark();
		clearLCDLine(0);
		clearLCDLine(1);
	}
	stopTask(auto_intake_cont);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	displayLCDCenteredString(0, "Drive Control");
	displayLCDCenteredString(1, "is Running!");
	startTask (t_catapultControl);
	startTask (t_engage_catapult);

	while (true)
	{
		arcadeControl();
		intakeControl();
		//catapultControl();
	}
}
